# Epic 4 Story 4.2: Data Protection & Encryption

## Business Context
**Epic**: Enterprise Compliance & Advanced Customization  
**Story**: 4.2 - Data Protection & Encryption  
**Depends On**: Story 4.1 (SOC 2 Compliance Framework)  
**Estimated Effort**: 3.5 hours  
**Business Value**: Enterprise-grade data protection enabling secure handling of sensitive real estate and customer data

### Business Problem
Enterprise clients require advanced data protection and encryption capabilities beyond basic SOC 2 compliance. Real estate platforms handle highly sensitive data including financial records, personal information, property details, and proprietary business intelligence that must be protected with military-grade encryption and comprehensive data classification systems.

### Business Solution
Implement a comprehensive data protection and encryption system that provides end-to-end security for all sensitive data, automated key management with rotation, data classification workflows, and enterprise-grade encryption both at rest and in transit. This builds upon the SOC 2 foundation to create a security-first architecture that exceeds enterprise compliance requirements.

## Method Analysis

### Business Requirements
- **BR-4.2.1**: Implement AES-256 encryption for all data at rest
- **BR-4.2.2**: Enforce TLS 1.3 with perfect forward secrecy for data in transit
- **BR-4.2.3**: Automated key management with 90-day rotation cycles
- **BR-4.2.4**: Data classification system with 4 sensitivity levels
- **BR-4.2.5**: Field-level encryption for PII and financial data
- **BR-4.2.6**: Encrypted backup and disaster recovery processes
- **BR-4.2.7**: Zero-knowledge architecture for maximum privacy
- **BR-4.2.8**: Compliance with GDPR, CCPA, and SOX requirements

### Architecture Decision
Building upon Story 4.1's SOC 2 compliance infrastructure, we'll implement a layered security architecture with envelope encryption, hardware security modules (HSM) integration, and comprehensive data protection workflows. The system will use AWS KMS for key management, implement field-level encryption at the application layer, and provide automated data classification with policy enforcement.

### Design Approach
1. **Encryption Layer Architecture**: Multi-tier encryption with envelope encryption pattern
2. **Key Management Service**: AWS KMS integration with automated rotation
3. **Data Classification Engine**: Automated PII detection and classification
4. **Secure Storage Layer**: Encrypted database columns with transparent encryption
5. **Transport Security**: TLS 1.3 with certificate pinning and HSTS
6. **Backup Encryption**: Encrypted backup processes with separate key management

## Acceptance Criteria

### Core Functionality
- [ ] All sensitive data encrypted at rest using AES-256-GCM
- [ ] TLS 1.3 enforced for all API communications with perfect forward secrecy
- [ ] Automated key rotation every 90 days with zero downtime
- [ ] Data classification system automatically categorizing all data
- [ ] Field-level encryption for PII, financial, and confidential data
- [ ] Encrypted backup and restore processes with integrity verification
- [ ] Zero-knowledge architecture preventing unauthorized data access
- [ ] Performance impact under 50ms for encryption/decryption operations

### Integration Requirements
- [ ] Seamless integration with Story 4.1 SOC 2 compliance framework
- [ ] Compatible with multi-tenant architecture from Epic 1
- [ ] Integration with audit logging system for all encryption operations
- [ ] Compliance reporting for GDPR, CCPA, and SOX requirements
- [ ] API gateway integration for transport layer security
- [ ] Database encryption integration with Supabase/PostgreSQL

### Technical Requirements
- [ ] Envelope encryption pattern with master and data encryption keys
- [ ] HSM integration for secure key storage and operations
- [ ] Automated threat detection for encryption key access patterns
- [ ] Performance monitoring for encryption operations
- [ ] Disaster recovery procedures for encrypted data
- [ ] Key escrow and recovery procedures for compliance

## Development Tasks

### Phase 1: Core Encryption Infrastructure (90 minutes)

#### Task 1.1: Encryption Service Foundation (30 minutes)
```python
# apps/api/app/services/encryption/encryption_service.py
import os
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from typing import Dict, Any, Optional
import boto3
from dataclasses import dataclass

@dataclass
class EncryptionMetadata:
    key_id: str
    algorithm: str
    created_at: str
    classification: str

class EncryptionService:
    def __init__(self):
        self.kms_client = boto3.client('kms')
        self.data_keys_cache = {}
        self.classification_levels = {
            'PUBLIC': 0,
            'INTERNAL': 1,
            'CONFIDENTIAL': 2,
            'RESTRICTED': 3
        }
    
    async def generate_data_key(self, key_id: str) -> Dict[str, bytes]:
        """Generate envelope encryption data key"""
        response = self.kms_client.generate_data_key(
            KeyId=key_id,
            KeySpec='AES_256'
        )
        return {
            'plaintext': response['Plaintext'],
            'encrypted': response['CiphertextBlob']
        }
    
    async def encrypt_field(self, 
                           value: Any, 
                           classification: str,
                           context: Optional[Dict] = None) -> Dict[str, Any]:
        """Encrypt individual field with metadata"""
        data_key = await self.generate_data_key(
            self._get_key_for_classification(classification)
        )
        
        # Use AESGCM for authenticated encryption
        aesgcm = AESGCM(data_key['plaintext'])
        nonce = os.urandom(12)
        
        encrypted_data = aesgcm.encrypt(
            nonce, 
            str(value).encode(), 
            associated_data=json.dumps(context or {}).encode()
        )
        
        return {
            'encrypted_value': base64.b64encode(encrypted_data).decode(),
            'encrypted_key': base64.b64encode(data_key['encrypted']).decode(),
            'nonce': base64.b64encode(nonce).decode(),
            'metadata': EncryptionMetadata(
                key_id=self._get_key_for_classification(classification),
                algorithm='AES-256-GCM',
                created_at=datetime.utcnow().isoformat(),
                classification=classification
            )
        }
```

#### Task 1.2: Key Management System (30 minutes)
```python
# apps/api/app/services/encryption/key_management.py
from datetime import datetime, timedelta
import asyncio
from typing import List, Dict, Optional

class KeyManagementService:
    def __init__(self, encryption_service: EncryptionService):
        self.encryption_service = encryption_service
        self.rotation_schedule = {}
        self.key_registry = {}
    
    async def create_master_key(self, 
                               purpose: str, 
                               classification: str) -> str:
        """Create new KMS master key with proper policies"""
        policy = self._generate_key_policy(classification)
        
        response = self.encryption_service.kms_client.create_key(
            Policy=json.dumps(policy),
            Description=f"Master key for {purpose} - {classification}",
            KeyUsage='ENCRYPT_DECRYPT',
            KeySpec='SYMMETRIC_DEFAULT',
            Tags=[
                {'TagKey': 'Purpose', 'TagValue': purpose},
                {'TagKey': 'Classification', 'TagValue': classification},
                {'TagKey': 'AutoRotate', 'TagValue': 'true'}
            ]
        )
        
        key_id = response['KeyMetadata']['KeyId']
        await self._schedule_key_rotation(key_id, 90)  # 90-day rotation
        
        return key_id
    
    async def rotate_key(self, key_id: str) -> bool:
        """Rotate encryption key with zero downtime"""
        try:
            # Enable automatic rotation
            self.encryption_service.kms_client.enable_key_rotation(KeyId=key_id)
            
            # Update rotation schedule
            await self._schedule_key_rotation(key_id, 90)
            
            # Log rotation event
            await self._log_key_event(key_id, 'ROTATION_COMPLETED')
            
            return True
        except Exception as e:
            await self._log_key_event(key_id, 'ROTATION_FAILED', str(e))
            return False
    
    async def _schedule_key_rotation(self, key_id: str, days: int):
        """Schedule automatic key rotation"""
        next_rotation = datetime.utcnow() + timedelta(days=days)
        self.rotation_schedule[key_id] = next_rotation
        
        # Schedule background task
        asyncio.create_task(
            self._wait_for_rotation(key_id, next_rotation)
        )
```

#### Task 1.3: Data Classification Engine (30 minutes)
```python
# apps/api/app/services/encryption/data_classifier.py
import re
from typing import Dict, List, Any
from enum import Enum

class DataClassification(Enum):
    PUBLIC = "PUBLIC"
    INTERNAL = "INTERNAL"
    CONFIDENTIAL = "CONFIDENTIAL"
    RESTRICTED = "RESTRICTED"

class DataClassificationService:
    def __init__(self):
        self.classification_rules = {
            'ssn': DataClassification.RESTRICTED,
            'credit_card': DataClassification.RESTRICTED,
            'email': DataClassification.CONFIDENTIAL,
            'phone': DataClassification.CONFIDENTIAL,
            'property_value': DataClassification.CONFIDENTIAL,
            'financial_data': DataClassification.RESTRICTED,
            'personal_data': DataClassification.CONFIDENTIAL
        }
        
        self.detection_patterns = {
            'ssn': re.compile(r'\b\d{3}-\d{2}-\d{4}\b'),
            'credit_card': re.compile(r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b'),
            'email': re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'),
            'phone': re.compile(r'\b\d{3}[- ]?\d{3}[- ]?\d{4}\b'),
            'property_value': re.compile(r'\$\d{1,3}(?:,\d{3})*(?:\.\d{2})?')
        }
    
    async def classify_data(self, data: Dict[str, Any]) -> Dict[str, DataClassification]:
        """Automatically classify data fields"""
        classifications = {}
        
        for field_name, field_value in data.items():
            classification = await self._classify_field(field_name, field_value)
            classifications[field_name] = classification
        
        return classifications
    
    async def _classify_field(self, field_name: str, field_value: Any) -> DataClassification:
        """Classify individual field"""
        field_str = str(field_value)
        
        # Check field name patterns
        field_lower = field_name.lower()
        if any(sensitive in field_lower for sensitive in ['ssn', 'social']):
            return DataClassification.RESTRICTED
        if any(pii in field_lower for pii in ['email', 'phone', 'address']):
            return DataClassification.CONFIDENTIAL
        
        # Check value patterns
        for pattern_name, pattern in self.detection_patterns.items():
            if pattern.search(field_str):
                return self.classification_rules[pattern_name]
        
        # Default classification
        return DataClassification.INTERNAL
    
    async def get_encryption_requirements(self, classification: DataClassification) -> Dict[str, Any]:
        """Get encryption requirements based on classification"""
        requirements = {
            DataClassification.PUBLIC: {
                'encrypt': False,
                'algorithm': None,
                'key_rotation_days': None
            },
            DataClassification.INTERNAL: {
                'encrypt': True,
                'algorithm': 'AES-256',
                'key_rotation_days': 365
            },
            DataClassification.CONFIDENTIAL: {
                'encrypt': True,
                'algorithm': 'AES-256-GCM',
                'key_rotation_days': 90
            },
            DataClassification.RESTRICTED: {
                'encrypt': True,
                'algorithm': 'AES-256-GCM',
                'key_rotation_days': 30,
                'additional_controls': ['audit_all_access', 'require_mfa']
            }
        }
        
        return requirements[classification]
```

### Phase 2: Database Encryption Integration (60 minutes)

#### Task 2.1: Encrypted Model Decorators (30 minutes)
```python
# apps/api/app/models/encrypted_models.py
from sqlalchemy import Column, String, Text, DateTime, LargeBinary
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.hybrid import hybrid_property
from app.services.encryption import EncryptionService, DataClassificationService
import json
from typing import Any, Optional

class EncryptedField:
    def __init__(self, classification: str = 'CONFIDENTIAL'):
        self.classification = classification
        self.encryption_service = EncryptionService()
    
    def __set_name__(self, owner, name):
        self.private_name = f'_{name}'
        self.encrypted_name = f'{name}_encrypted'
        self.metadata_name = f'{name}_encryption_metadata'
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        
        encrypted_data = getattr(obj, self.encrypted_name, None)
        if encrypted_data is None:
            return None
        
        return self._decrypt_value(obj, encrypted_data)
    
    def __set__(self, obj, value):
        if value is None:
            setattr(obj, self.encrypted_name, None)
            setattr(obj, self.metadata_name, None)
            return
        
        encrypted_result = self._encrypt_value(value)
        setattr(obj, self.encrypted_name, encrypted_result['encrypted_data'])
        setattr(obj, self.metadata_name, json.dumps(encrypted_result['metadata']))
    
    async def _encrypt_value(self, value: Any) -> Dict[str, Any]:
        """Encrypt value with metadata"""
        return await self.encryption_service.encrypt_field(
            value=value,
            classification=self.classification,
            context={'field_type': type(value).__name__}
        )
    
    async def _decrypt_value(self, obj, encrypted_data: str) -> Any:
        """Decrypt value using stored metadata"""
        metadata_json = getattr(obj, self.metadata_name)
        metadata = json.loads(metadata_json) if metadata_json else {}
        
        return await self.encryption_service.decrypt_field(
            encrypted_data=encrypted_data,
            metadata=metadata
        )

# Enhanced Property model with encryption
class EncryptedProperty(Base):
    __tablename__ = 'properties_encrypted'
    
    id = Column(String, primary_key=True)
    
    # Encrypted fields using decorators
    owner_ssn = EncryptedField(classification='RESTRICTED')
    financial_details = EncryptedField(classification='RESTRICTED')
    owner_email = EncryptedField(classification='CONFIDENTIAL')
    property_address = EncryptedField(classification='CONFIDENTIAL')
    
    # Database storage for encrypted data
    owner_ssn_encrypted = Column(Text)
    owner_ssn_encryption_metadata = Column(Text)
    financial_details_encrypted = Column(Text)
    financial_details_encryption_metadata = Column(Text)
    owner_email_encrypted = Column(Text)
    owner_email_encryption_metadata = Column(Text)
    property_address_encrypted = Column(Text)
    property_address_encryption_metadata = Column(Text)
    
    created_at = Column(DateTime)
    updated_at = Column(DateTime)
```

#### Task 2.2: Transparent Database Encryption (30 minutes)
```python
# apps/api/app/services/database/encrypted_repository.py
from sqlalchemy.orm import Session
from typing import Dict, List, Any, Optional, Type
from app.services.encryption import EncryptionService, DataClassificationService

class EncryptedRepository:
    def __init__(self, db: Session):
        self.db = db
        self.encryption_service = EncryptionService()
        self.classifier = DataClassificationService()
    
    async def create_encrypted(self, 
                              model_class: Type,
                              data: Dict[str, Any]) -> Any:
        """Create model instance with automatic encryption"""
        # Classify data first
        classifications = await self.classifier.classify_data(data)
        
        # Prepare encrypted data
        encrypted_data = {}
        for field, value in data.items():
            classification = classifications.get(field)
            requirements = await self.classifier.get_encryption_requirements(classification)
            
            if requirements['encrypt']:
                encrypted_result = await self.encryption_service.encrypt_field(
                    value=value,
                    classification=classification.value
                )
                encrypted_data[f"{field}_encrypted"] = encrypted_result['encrypted_value']
                encrypted_data[f"{field}_encryption_metadata"] = json.dumps(encrypted_result['metadata'])
            else:
                encrypted_data[field] = value
        
        # Create model instance
        instance = model_class(**encrypted_data)
        self.db.add(instance)
        await self.db.commit()
        
        return instance
    
    async def query_encrypted(self, 
                             model_class: Type,
                             filters: Dict[str, Any] = None) -> List[Any]:
        """Query with automatic decryption"""
        query = self.db.query(model_class)
        
        if filters:
            # Handle encrypted field queries
            for field, value in filters.items():
                if hasattr(model_class, f"{field}_encrypted"):
                    # For encrypted fields, we need to encrypt the search value
                    # This is simplified - in practice, you'd use searchable encryption
                    continue
                else:
                    query = query.filter(getattr(model_class, field) == value)
        
        results = query.all()
        
        # Decrypt results automatically handled by model properties
        return results
    
    async def backup_encrypted_data(self, table_name: str) -> Dict[str, Any]:
        """Create encrypted backup with separate key management"""
        backup_key = await self.encryption_service.generate_backup_key()
        
        # Export encrypted data
        query = f"SELECT * FROM {table_name}"
        raw_data = self.db.execute(query).fetchall()
        
        # Re-encrypt with backup key
        backup_data = []
        for row in raw_data:
            encrypted_row = await self.encryption_service.encrypt_for_backup(
                data=dict(row),
                backup_key=backup_key
            )
            backup_data.append(encrypted_row)
        
        return {
            'data': backup_data,
            'backup_key_id': backup_key['key_id'],
            'timestamp': datetime.utcnow().isoformat(),
            'integrity_hash': self._calculate_integrity_hash(backup_data)
        }
```

### Phase 3: Transport Layer Security (60 minutes)

#### Task 3.1: TLS 1.3 Configuration (30 minutes)
```python
# apps/api/app/core/security_config.py
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
import ssl
from typing import Dict, Any

class TransportSecurityManager:
    def __init__(self, app: FastAPI):
        self.app = app
        self.configure_tls()
        self.configure_security_headers()
    
    def configure_tls(self):
        """Configure TLS 1.3 with perfect forward secrecy"""
        # HTTPS redirect middleware
        self.app.add_middleware(HTTPSRedirectMiddleware)
        
        # Trusted host middleware
        self.app.add_middleware(
            TrustedHostMiddleware, 
            allowed_hosts=["*.seiketsu.ai", "localhost"]
        )
        
        # TLS configuration for uvicorn
        self.tls_config = {
            'ssl_version': ssl.PROTOCOL_TLS_SERVER,
            'ssl_ciphers': self._get_secure_ciphers(),
            'ssl_options': (
                ssl.OP_NO_SSLv2 | 
                ssl.OP_NO_SSLv3 | 
                ssl.OP_NO_TLSv1 | 
                ssl.OP_NO_TLSv1_1 |
                ssl.OP_CIPHER_SERVER_PREFERENCE
            )
        }
    
    def _get_secure_ciphers(self) -> str:
        """Get TLS 1.3 cipher suites with perfect forward secrecy"""
        return ':'.join([
            'TLS_AES_256_GCM_SHA384',
            'TLS_CHACHA20_POLY1305_SHA256',
            'TLS_AES_128_GCM_SHA256',
            'ECDHE-RSA-AES256-GCM-SHA384',
            'ECDHE-RSA-CHACHA20-POLY1305',
            'ECDHE-RSA-AES128-GCM-SHA256'
        ])
    
    def configure_security_headers(self):
        """Configure security headers middleware"""
        @self.app.middleware("http")
        async def security_headers_middleware(request: Request, call_next):
            response = await call_next(request)
            
            # HSTS with long max-age
            response.headers["Strict-Transport-Security"] = (
                "max-age=31536000; includeSubDomains; preload"
            )
            
            # Certificate pinning via HPKP
            response.headers["Public-Key-Pins"] = (
                'pin-sha256="base64+primary=="; '
                'pin-sha256="base64+backup=="; '
                'max-age=2592000; includeSubDomains'
            )
            
            # Content Security Policy
            response.headers["Content-Security-Policy"] = (
                "default-src 'self'; "
                "script-src 'self' 'unsafe-inline'; "
                "style-src 'self' 'unsafe-inline'; "
                "img-src 'self' data: https:; "
                "connect-src 'self' wss: https:; "
                "upgrade-insecure-requests"
            )
            
            # Additional security headers
            response.headers["X-Content-Type-Options"] = "nosniff"
            response.headers["X-Frame-Options"] = "DENY"
            response.headers["X-XSS-Protection"] = "1; mode=block"
            response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
            
            return response
```

#### Task 3.2: Certificate Management (30 minutes)
```python
# apps/api/app/services/security/certificate_manager.py
import ssl
import socket
from datetime import datetime, timedelta
from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
import boto3
from typing import Dict, List, Optional

class CertificateManager:
    def __init__(self):
        self.acm_client = boto3.client('acm')
        self.certificate_store = {}
        
    async def provision_certificate(self, domain: str) -> Dict[str, Any]:
        """Provision SSL certificate with auto-renewal"""
        try:
            # Request certificate from ACM
            response = self.acm_client.request_certificate(
                DomainName=domain,
                SubjectAlternativeNames=[f"*.{domain}"],
                ValidationMethod='DNS',
                KeyAlgorithm='EC_secp384r1',  # Elliptic curve for better performance
                Tags=[
                    {'Key': 'AutoRenew', 'Value': 'true'},
                    {'Key': 'Service', 'Value': 'seiketsu-ai'}
                ]
            )
            
            certificate_arn = response['CertificateArn']
            
            # Schedule renewal check
            await self._schedule_renewal_check(certificate_arn)
            
            return {
                'certificate_arn': certificate_arn,
                'domain': domain,
                'status': 'pending_validation',
                'validation_method': 'DNS'
            }
            
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Certificate provisioning failed: {str(e)}"
            )
    
    async def validate_certificate_chain(self, certificate_arn: str) -> bool:
        """Validate certificate chain and configuration"""
        try:
            cert_details = self.acm_client.describe_certificate(
                CertificateArn=certificate_arn
            )
            
            certificate = cert_details['Certificate']
            
            # Check certificate validity
            not_after = certificate['NotAfter']
            days_until_expiry = (not_after - datetime.utcnow()).days
            
            if days_until_expiry < 30:
                await self._trigger_renewal(certificate_arn)
            
            # Validate certificate chain
            chain_valid = await self._validate_chain(certificate['CertificateChain'])
            
            # Check for weak cryptography
            key_algorithm = certificate.get('KeyAlgorithm', '')
            if key_algorithm not in ['EC_secp384r1', 'RSA_2048', 'RSA_4096']:
                return False
            
            return chain_valid and days_until_expiry > 0
            
        except Exception as e:
            await self._log_certificate_error(certificate_arn, str(e))
            return False
    
    async def _schedule_renewal_check(self, certificate_arn: str):
        """Schedule automatic certificate renewal checks"""
        # In production, this would use a task queue like Celery
        import asyncio
        
        async def renewal_checker():
            while True:
                await asyncio.sleep(86400)  # Check daily
                await self.validate_certificate_chain(certificate_arn)
        
        asyncio.create_task(renewal_checker())
    
    async def generate_certificate_report(self) -> Dict[str, Any]:
        """Generate certificate status report"""
        certificates = self.acm_client.list_certificates()
        
        report = {
            'total_certificates': len(certificates['CertificateSummaryList']),
            'expiring_soon': [],
            'security_issues': [],
            'recommendations': []
        }
        
        for cert_summary in certificates['CertificateSummaryList']:
            cert_arn = cert_summary['CertificateArn']
            details = self.acm_client.describe_certificate(CertificateArn=cert_arn)
            cert = details['Certificate']
            
            # Check expiration
            days_until_expiry = (cert['NotAfter'] - datetime.utcnow()).days
            if days_until_expiry < 30:
                report['expiring_soon'].append({
                    'domain': cert['DomainName'],
                    'expires_in_days': days_until_expiry,
                    'certificate_arn': cert_arn
                })
            
            # Check security
            if cert.get('KeyAlgorithm') == 'RSA_1024':
                report['security_issues'].append({
                    'domain': cert['DomainName'],
                    'issue': 'Weak key algorithm (RSA-1024)',
                    'recommendation': 'Upgrade to RSA-2048 or EC_secp384r1'
                })
        
        return report
```

### Phase 4: Compliance Integration (40 minutes)

#### Task 4.1: GDPR Data Protection (20 minutes)
```python
# apps/api/app/services/compliance/gdpr_service.py
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
from app.services.encryption import EncryptionService
from app.models.encrypted_models import EncryptedProperty

class GDPRComplianceService:
    def __init__(self, encryption_service: EncryptionService):
        self.encryption_service = encryption_service
        self.data_retention_policies = {
            'personal_data': timedelta(days=2555),  # 7 years
            'marketing_data': timedelta(days=1095),  # 3 years
            'analytics_data': timedelta(days=365)    # 1 year
        }
    
    async def handle_data_subject_request(self, 
                                        request_type: str,
                                        subject_id: str,
                                        verification_token: str) -> Dict[str, Any]:
        """Handle GDPR data subject requests"""
        # Verify request authenticity
        if not await self._verify_data_subject(subject_id, verification_token):
            raise ValueError("Invalid data subject verification")
        
        if request_type == 'access':
            return await self._handle_access_request(subject_id)
        elif request_type == 'rectification':
            return await self._handle_rectification_request(subject_id)
        elif request_type == 'erasure':
            return await self._handle_erasure_request(subject_id)
        elif request_type == 'portability':
            return await self._handle_portability_request(subject_id)
        else:
            raise ValueError(f"Unknown request type: {request_type}")
    
    async def _handle_access_request(self, subject_id: str) -> Dict[str, Any]:
        """Provide all personal data for subject"""
        # Query all data related to subject
        personal_data = await self._collect_personal_data(subject_id)
        
        # Decrypt sensitive fields for export
        decrypted_data = {}
        for table, records in personal_data.items():
            decrypted_records = []
            for record in records:
                decrypted_record = await self._decrypt_record(record)
                decrypted_records.append(decrypted_record)
            decrypted_data[table] = decrypted_records
        
        # Create audit trail
        await self._log_gdpr_action(
            subject_id=subject_id,
            action='data_access',
            timestamp=datetime.utcnow(),
            data_scope=list(decrypted_data.keys())
        )
        
        return {
            'subject_id': subject_id,
            'data': decrypted_data,
            'generated_at': datetime.utcnow().isoformat(),
            'format': 'JSON',
            'retention_info': await self._get_retention_info(subject_id)
        }
    
    async def _handle_erasure_request(self, subject_id: str) -> Dict[str, Any]:
        """Right to be forgotten implementation"""
        # Identify all data to be erased
        erasure_scope = await self._identify_erasure_scope(subject_id)
        
        # Check for legal holds
        legal_holds = await self._check_legal_holds(subject_id)
        if legal_holds:
            return {
                'status': 'partial_erasure',
                'reason': 'Legal obligation prevents full erasure',
                'retained_data': legal_holds,
                'erased_data': []
            }
        
        # Cryptographic erasure - destroy encryption keys
        erased_data = []
        for table, records in erasure_scope.items():
            for record in records:
                # Destroy encryption keys instead of data deletion
                await self._cryptographic_erasure(record)
                erased_data.append({
                    'table': table,
                    'record_id': record['id'],
                    'erasure_method': 'cryptographic'
                })
        
        # Log erasure action
        await self._log_gdpr_action(
            subject_id=subject_id,
            action='data_erasure',
            timestamp=datetime.utcnow(),
            data_scope=erased_data
        )
        
        return {
            'status': 'complete_erasure',
            'erased_records': len(erased_data),
            'erasure_timestamp': datetime.utcnow().isoformat(),
            'verification_hash': await self._generate_erasure_proof(erased_data)
        }
    
    async def _cryptographic_erasure(self, record: Dict[str, Any]):
        """Implement cryptographic erasure by destroying keys"""
        # Identify encryption keys used for this record
        encryption_metadata = record.get('encryption_metadata', {})
        key_ids = []
        
        for field_metadata in encryption_metadata.values():
            if isinstance(field_metadata, str):
                metadata = json.loads(field_metadata)
                key_ids.append(metadata.get('key_id'))
        
        # Schedule key destruction
        for key_id in set(key_ids):
            await self.encryption_service.schedule_key_destruction(
                key_id=key_id,
                destruction_date=datetime.utcnow() + timedelta(days=7)
            )
```

#### Task 4.2: Automated Compliance Reporting (20 minutes)
```python
# apps/api/app/services/compliance/compliance_reporter.py
from typing import Dict, List, Any
from datetime import datetime, timedelta
import json

class ComplianceReporter:
    def __init__(self, encryption_service: EncryptionService):
        self.encryption_service = encryption_service
        self.compliance_frameworks = ['SOC2', 'GDPR', 'CCPA', 'SOX']
    
    async def generate_encryption_compliance_report(self) -> Dict[str, Any]:
        """Generate comprehensive encryption compliance report"""
        report = {
            'report_id': f"ENC-{datetime.utcnow().strftime('%Y%m%d-%H%M%S')}",
            'generated_at': datetime.utcnow().isoformat(),
            'reporting_period': {
                'start': (datetime.utcnow() - timedelta(days=30)).isoformat(),
                'end': datetime.utcnow().isoformat()
            },
            'compliance_status': {},
            'encryption_metrics': await self._collect_encryption_metrics(),
            'key_management_status': await self._audit_key_management(),
            'data_protection_compliance': await self._assess_data_protection(),
            'recommendations': []
        }
        
        # Assess compliance for each framework
        for framework in self.compliance_frameworks:
            status = await self._assess_framework_compliance(framework)
            report['compliance_status'][framework] = status
        
        # Generate recommendations
        report['recommendations'] = await self._generate_compliance_recommendations(
            report['compliance_status']
        )
        
        return report
    
    async def _collect_encryption_metrics(self) -> Dict[str, Any]:
        """Collect encryption performance and coverage metrics"""
        return {
            'data_at_rest': {
                'encrypted_tables': await self._count_encrypted_tables(),
                'encryption_coverage_percentage': await self._calculate_encryption_coverage(),
                'average_encryption_time_ms': await self._get_avg_encryption_time()
            },
            'data_in_transit': {
                'tls_version_distribution': await self._get_tls_version_stats(),
                'certificate_status': await self._get_certificate_health(),
                'failed_connection_attempts': await self._get_failed_connections()
            },
            'key_management': {
                'active_keys': await self._count_active_keys(),
                'key_rotation_compliance': await self._check_rotation_compliance(),
                'key_access_patterns': await self._analyze_key_access()
            }
        }
    
    async def _assess_framework_compliance(self, framework: str) -> Dict[str, Any]:
        """Assess compliance with specific framework"""
        compliance_checks = {
            'SOC2': [
                'encryption_at_rest_enabled',
                'encryption_in_transit_enforced',
                'key_rotation_automated',
                'access_controls_implemented',
                'audit_logging_enabled'
            ],
            'GDPR': [
                'pseudonymization_implemented',
                'encryption_for_personal_data',
                'data_breach_detection',
                'privacy_by_design',
                'data_subject_rights_supported'
            ],
            'CCPA': [
                'consumer_data_encrypted',
                'data_deletion_capabilities',
                'third_party_sharing_controls',
                'opt_out_mechanisms'
            ],
            'SOX': [
                'financial_data_encryption',
                'access_controls_financial_systems',
                'audit_trail_integrity',
                'segregation_of_duties'
            ]
        }
        
        results = {}
        total_checks = len(compliance_checks[framework])
        passed_checks = 0
        
        for check in compliance_checks[framework]:
            result = await self._perform_compliance_check(check)
            results[check] = result
            if result['status'] == 'PASS':
                passed_checks += 1
        
        compliance_percentage = (passed_checks / total_checks) * 100
        
        return {
            'framework': framework,
            'compliance_percentage': compliance_percentage,
            'status': 'COMPLIANT' if compliance_percentage >= 95 else 'NON_COMPLIANT',
            'check_results': results,
            'last_assessment': datetime.utcnow().isoformat()
        }
    
    async def _perform_compliance_check(self, check_name: str) -> Dict[str, Any]:
        """Perform individual compliance check"""
        check_methods = {
            'encryption_at_rest_enabled': self._check_database_encryption,
            'encryption_in_transit_enforced': self._check_tls_enforcement,
            'key_rotation_automated': self._check_key_rotation,
            'access_controls_implemented': self._check_access_controls,
            'audit_logging_enabled': self._check_audit_logging
        }
        
        if check_name in check_methods:
            return await check_methods[check_name]()
        else:
            return {
                'status': 'UNKNOWN',
                'message': f'Check method not implemented: {check_name}',
                'evidence': None
            }
```

## Test Cases

### Unit Tests
```python
# tests/test_encryption_service.py
import pytest
from app.services.encryption import EncryptionService, DataClassificationService

class TestEncryptionService:
    @pytest.fixture
    def encryption_service(self):
        return EncryptionService()
    
    @pytest.fixture
    def classifier(self):
        return DataClassificationService()
    
    async def test_field_encryption_restricted_data(self, encryption_service):
        """Test encryption of restricted data fields"""
        # Arrange
        ssn = "123-45-6789"
        classification = "RESTRICTED"
        
        # Act
        result = await encryption_service.encrypt_field(
            value=ssn,
            classification=classification
        )
        
        # Assert
        assert 'encrypted_value' in result
        assert 'encrypted_key' in result
        assert 'metadata' in result
        assert result['metadata'].algorithm == 'AES-256-GCM'
        assert result['metadata'].classification == classification
    
    async def test_data_classification_ssn_detection(self, classifier):
        """Test automatic SSN detection and classification"""
        # Arrange
        data = {
            'name': 'John Doe',
            'ssn': '123-45-6789',
            'email': 'john@example.com'
        }
        
        # Act
        classifications = await classifier.classify_data(data)
        
        # Assert
        assert classifications['ssn'] == DataClassification.RESTRICTED
        assert classifications['email'] == DataClassification.CONFIDENTIAL
        assert classifications['name'] == DataClassification.INTERNAL
    
    async def test_key_rotation_zero_downtime(self, encryption_service):
        """Test key rotation without service interruption"""
        # Arrange
        key_id = await encryption_service.kms_client.create_key()
        
        # Act
        rotation_result = await encryption_service.rotate_key(key_id)
        
        # Assert
        assert rotation_result is True
        # Verify old encrypted data still accessible
        # Verify new data uses new key
```

### Integration Tests
```python
# tests/test_gdpr_compliance.py
import pytest
from app.services.compliance import GDPRComplianceService

class TestGDPRCompliance:
    async def test_data_subject_access_request(self, gdpr_service, test_user):
        """Test complete data access request flow"""
        # Arrange
        subject_id = test_user.id
        verification_token = "valid_token"
        
        # Act
        result = await gdpr_service.handle_data_subject_request(
            request_type='access',
            subject_id=subject_id,
            verification_token=verification_token
        )
        
        # Assert
        assert 'data' in result
        assert 'retention_info' in result
        assert result['subject_id'] == subject_id
        # Verify audit trail created
    
    async def test_cryptographic_erasure(self, gdpr_service, test_user):
        """Test right to be forgotten with cryptographic erasure"""
        # Arrange
        subject_id = test_user.id
        
        # Act
        result = await gdpr_service.handle_data_subject_request(
            request_type='erasure',
            subject_id=subject_id,
            verification_token="valid_token"
        )
        
        # Assert
        assert result['status'] == 'complete_erasure'
        assert 'verification_hash' in result
        # Verify data is inaccessible after erasure
```

### Security Tests
```python
# tests/test_transport_security.py
import pytest
import ssl
from app.core.security_config import TransportSecurityManager

class TestTransportSecurity:
    async def test_tls_version_enforcement(self, security_manager):
        """Test TLS 1.3 enforcement and cipher selection"""
        # Test TLS version
        assert security_manager.tls_config['ssl_version'] == ssl.PROTOCOL_TLS_SERVER
        
        # Test cipher suites include only secure options
        ciphers = security_manager._get_secure_ciphers()
        assert 'TLS_AES_256_GCM_SHA384' in ciphers
        assert 'RC4' not in ciphers  # Ensure weak ciphers excluded
    
    async def test_security_headers_presence(self, client):
        """Test security headers in HTTP responses"""
        # Act
        response = await client.get("/api/health")
        
        # Assert
        assert "Strict-Transport-Security" in response.headers
        assert "Content-Security-Policy" in response.headers
        assert "X-Frame-Options" in response.headers
        assert response.headers["X-Frame-Options"] == "DENY"
```

### Performance Tests
```python
# tests/test_encryption_performance.py
import pytest
import time
from app.services.encryption import EncryptionService

class TestEncryptionPerformance:
    async def test_encryption_performance_benchmark(self, encryption_service):
        """Test encryption performance meets SLA requirements"""
        # Arrange
        test_data = "This is sensitive test data" * 100
        iterations = 1000
        
        # Act
        start_time = time.time()
        for _ in range(iterations):
            await encryption_service.encrypt_field(
                value=test_data,
                classification="CONFIDENTIAL"
            )
        end_time = time.time()
        
        # Assert
        avg_time_ms = ((end_time - start_time) / iterations) * 1000
        assert avg_time_ms < 50, f"Encryption too slow: {avg_time_ms}ms > 50ms"
    
    async def test_bulk_encryption_scalability(self, encryption_service):
        """Test bulk encryption operations scale linearly"""
        batch_sizes = [10, 100, 1000]
        performance_data = []
        
        for batch_size in batch_sizes:
            start_time = time.time()
            
            tasks = []
            for i in range(batch_size):
                task = encryption_service.encrypt_field(
                    value=f"test_data_{i}",
                    classification="CONFIDENTIAL"
                )
                tasks.append(task)
            
            await asyncio.gather(*tasks)
            
            elapsed_time = time.time() - start_time
            performance_data.append({
                'batch_size': batch_size,
                'total_time': elapsed_time,
                'time_per_operation': elapsed_time / batch_size
            })
        
        # Assert linear scaling (allow for 20% variance)
        base_time_per_op = performance_data[0]['time_per_operation']
        for data in performance_data[1:]:
            variance = abs(data['time_per_operation'] - base_time_per_op) / base_time_per_op
            assert variance < 0.2, f"Performance degradation: {variance:.2%}"
```

## Deliverables

### Code Components
1. **Encryption Service Layer** (`/apps/api/app/services/encryption/`)
   - `encryption_service.py` - Core encryption operations
   - `key_management.py` - Automated key management and rotation
   - `data_classifier.py` - Automated data classification engine

2. **Database Integration** (`/apps/api/app/models/`)
   - `encrypted_models.py` - Encrypted model decorators and field types
   - `encrypted_repository.py` - Transparent encryption repository pattern

3. **Transport Security** (`/apps/api/app/core/`)
   - `security_config.py` - TLS 1.3 configuration and security headers
   - `certificate_manager.py` - SSL certificate lifecycle management

4. **Compliance Integration** (`/apps/api/app/services/compliance/`)
   - `gdpr_service.py` - GDPR data subject rights implementation
   - `compliance_reporter.py` - Automated compliance reporting

### Configuration Files
1. **Encryption Configuration** - Key management policies and rotation schedules
2. **TLS Configuration** - Cipher suites and security policies
3. **Compliance Policies** - Data retention and protection policies

### Testing Suite
1. **Unit Tests** - Individual component testing with 95%+ coverage
2. **Integration Tests** - End-to-end encryption and compliance workflows
3. **Security Tests** - Penetration testing and vulnerability assessment
4. **Performance Tests** - Encryption performance benchmarks and scaling tests

### Documentation
1. **Security Architecture Documentation** - Encryption design and threat model
2. **Compliance Mapping** - Framework compliance evidence and controls
3. **Operational Runbooks** - Key rotation, incident response, and recovery procedures
4. **API Security Documentation** - Security implementation details for developers

## Success Metrics

### Security Metrics
- **Encryption Coverage**: 100% of sensitive data encrypted at rest and in transit
- **Key Rotation Compliance**: 100% automated rotation within policy timeframes  
- **Performance Impact**: <50ms average encryption/decryption latency
- **Security Incidents**: Zero data breaches or unauthorized access events

### Compliance Metrics
- **Framework Compliance**: 95%+ compliance score across SOC 2, GDPR, CCPA, SOX
- **Audit Readiness**: 100% of encryption operations logged and auditable
- **Data Subject Requests**: 100% of GDPR requests processed within 30 days
- **Compliance Reporting**: Automated reports generated monthly

### Operational Metrics
- **System Availability**: 99.9% uptime during encryption operations
- **Recovery Time**: <1 hour for encrypted data recovery procedures
- **Backup Success**: 100% encrypted backup completion rate
- **Certificate Health**: 100% valid certificates with >30 days until expiry

This story delivers enterprise-grade data protection and encryption capabilities that build upon the SOC 2 compliance foundation, providing comprehensive security for sensitive real estate and customer data while maintaining high performance and operational efficiency.